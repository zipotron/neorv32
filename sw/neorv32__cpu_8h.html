<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NEORV32 - Software Framework Documentation: sw/lib/include/neorv32_cpu.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="neorv32_logo_transparent_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NEORV32 - Software Framework Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_01fcd3835fb4e7d9331b722d86291b65.html">sw</a></li><li class="navelem"><a class="el" href="dir_7d04193005ada6f9450f847f4adb6b5b.html">lib</a></li><li class="navelem"><a class="el" href="dir_752b1e5d3973bf735fa78bf6b4727df9.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">neorv32_cpu.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>CPU Core Functions HW driver header file.  
<a href="#details">More...</a></p>

<p><a href="neorv32__cpu_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1128a30988815e8195618da07c13a345"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#a1128a30988815e8195618da07c13a345">neorv32_cpu_irq_enable</a> (uint8_t irq_sel)</td></tr>
<tr class="separator:a1128a30988815e8195618da07c13a345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c3b55f5b7042ed2470b2fe7d0ce0c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#a57c3b55f5b7042ed2470b2fe7d0ce0c7">neorv32_cpu_irq_disable</a> (uint8_t irq_sel)</td></tr>
<tr class="separator:a57c3b55f5b7042ed2470b2fe7d0ce0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fd7dc7cd1e0a08225c41820af27f92"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#ac3fd7dc7cd1e0a08225c41820af27f92">neorv32_cpu_get_cycle</a> (void)</td></tr>
<tr class="separator:ac3fd7dc7cd1e0a08225c41820af27f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232d0290c459dc790d989fcdc4d121bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#a232d0290c459dc790d989fcdc4d121bf">neorv32_cpu_set_mcycle</a> (uint64_t value)</td></tr>
<tr class="separator:a232d0290c459dc790d989fcdc4d121bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387aa304770b05594c4acca128a60a75"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#a387aa304770b05594c4acca128a60a75">neorv32_cpu_get_instret</a> (void)</td></tr>
<tr class="separator:a387aa304770b05594c4acca128a60a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3cf52498abb3cf3c14a724b287ecf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#a5c3cf52498abb3cf3c14a724b287ecf0">neorv32_cpu_set_minstret</a> (uint64_t value)</td></tr>
<tr class="separator:a5c3cf52498abb3cf3c14a724b287ecf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7e66d338a86207c4a510dc4d913874"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#a9d7e66d338a86207c4a510dc4d913874">neorv32_cpu_get_systime</a> (void)</td></tr>
<tr class="separator:a9d7e66d338a86207c4a510dc4d913874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9027535b13d9f9325e734997fc4a137"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#aa9027535b13d9f9325e734997fc4a137">neorv32_cpu_delay_ms</a> (uint32_t time_ms)</td></tr>
<tr class="separator:aa9027535b13d9f9325e734997fc4a137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca49efb45d3808ad76cf65ba291f546d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#aca49efb45d3808ad76cf65ba291f546d">neorv32_cpu_goto_user_mode</a> (void)</td></tr>
<tr class="separator:aca49efb45d3808ad76cf65ba291f546d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27dd614bc270dfa30ed73323ebda2d2d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#a27dd614bc270dfa30ed73323ebda2d2d">neorv32_cpu_pmp_get_num_regions</a> (void)</td></tr>
<tr class="separator:a27dd614bc270dfa30ed73323ebda2d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f8160f4821b6691e9682ef60c7cd7b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#ad4f8160f4821b6691e9682ef60c7cd7b">neorv32_cpu_pmp_get_granularity</a> (void)</td></tr>
<tr class="separator:ad4f8160f4821b6691e9682ef60c7cd7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17dd397ea7409a1ecb0ea50b61e738a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#a17dd397ea7409a1ecb0ea50b61e738a5">neorv32_cpu_pmp_configure_region</a> (uint32_t index, uint32_t base, uint32_t size, uint8_t config)</td></tr>
<tr class="separator:a17dd397ea7409a1ecb0ea50b61e738a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c4f8502cafca5c369297c347079d44"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#a59c4f8502cafca5c369297c347079d44">neorv32_cpu_hpm_get_counters</a> (void)</td></tr>
<tr class="separator:a59c4f8502cafca5c369297c347079d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3ae542bbb0ddf9f562a4e42bc24d10"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#adb3ae542bbb0ddf9f562a4e42bc24d10">neorv32_cpu_hpm_get_size</a> (void)</td></tr>
<tr class="separator:adb3ae542bbb0ddf9f562a4e42bc24d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cc6c8048acaaa5fdf35ad7df63ce37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#a94cc6c8048acaaa5fdf35ad7df63ce37">__neorv32_crt0_after_main</a> (int32_t return_code)</td></tr>
<tr class="separator:a94cc6c8048acaaa5fdf35ad7df63ce37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198a49fc1b6c243418f29af9bbe19cec"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#a198a49fc1b6c243418f29af9bbe19cec">neorv32_cpu_store_conditional</a> (uint32_t addr, uint32_t wdata)</td></tr>
<tr class="separator:a198a49fc1b6c243418f29af9bbe19cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173bb06b4ae9c8964469068dafcb7b0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#a173bb06b4ae9c8964469068dafcb7b0e">neorv32_cpu_store_unsigned_word</a> (uint32_t addr, uint32_t wdata)</td></tr>
<tr class="separator:a173bb06b4ae9c8964469068dafcb7b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f30f6d6542758cd3073a9939b07653"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#a31f30f6d6542758cd3073a9939b07653">neorv32_cpu_store_unsigned_half</a> (uint32_t addr, uint16_t wdata)</td></tr>
<tr class="separator:a31f30f6d6542758cd3073a9939b07653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec8ad2a82885c40a307346f9003483e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#aeec8ad2a82885c40a307346f9003483e">neorv32_cpu_store_unsigned_byte</a> (uint32_t addr, uint8_t wdata)</td></tr>
<tr class="separator:aeec8ad2a82885c40a307346f9003483e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a8539d4e17d6a409f288e118bc46af"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#a75a8539d4e17d6a409f288e118bc46af">neorv32_cpu_load_reservate_word</a> (uint32_t addr)</td></tr>
<tr class="separator:a75a8539d4e17d6a409f288e118bc46af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6cf445e2136486564ef3d3473c91dd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#a3b6cf445e2136486564ef3d3473c91dd">neorv32_cpu_load_unsigned_word</a> (uint32_t addr)</td></tr>
<tr class="separator:a3b6cf445e2136486564ef3d3473c91dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32544cd652debb4affb308806a115d5b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#a32544cd652debb4affb308806a115d5b">neorv32_cpu_load_unsigned_half</a> (uint32_t addr)</td></tr>
<tr class="separator:a32544cd652debb4affb308806a115d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54ec9b59e17c7cd9b9907abee82ce95"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#ac54ec9b59e17c7cd9b9907abee82ce95">neorv32_cpu_load_unsigned_byte</a> (uint32_t addr)</td></tr>
<tr class="separator:ac54ec9b59e17c7cd9b9907abee82ce95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7a9f9cf608599f2b124dd499cb8418"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#aab7a9f9cf608599f2b124dd499cb8418">neorv32_cpu_csr_read</a> (const int csr_id)</td></tr>
<tr class="separator:aab7a9f9cf608599f2b124dd499cb8418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5ef6e0b1a3e26570edfd8379490455"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#afb5ef6e0b1a3e26570edfd8379490455">neorv32_cpu_csr_write</a> (const int csr_id, uint32_t data)</td></tr>
<tr class="separator:afb5ef6e0b1a3e26570edfd8379490455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769ca4556213619f6fea4ff6bfb979dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#a769ca4556213619f6fea4ff6bfb979dd">neorv32_cpu_sleep</a> (void)</td></tr>
<tr class="separator:a769ca4556213619f6fea4ff6bfb979dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00d513794932373f6dd2766d7efb4e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#ae00d513794932373f6dd2766d7efb4e1">neorv32_cpu_eint</a> (void)</td></tr>
<tr class="separator:ae00d513794932373f6dd2766d7efb4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e710118af168dad99d93ddd5940d43e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#a3e710118af168dad99d93ddd5940d43e">neorv32_cpu_dint</a> (void)</td></tr>
<tr class="separator:a3e710118af168dad99d93ddd5940d43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386919a8b7f37c2c37d2561bfb79d1ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#a386919a8b7f37c2c37d2561bfb79d1ff">neorv32_cpu_breakpoint</a> (void)</td></tr>
<tr class="separator:a386919a8b7f37c2c37d2561bfb79d1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a68d64b34162c5979a77bbb3c52bb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="neorv32__cpu_8h.html#a08a68d64b34162c5979a77bbb3c52bb6">neorv32_cpu_env_call</a> (void)</td></tr>
<tr class="separator:a08a68d64b34162c5979a77bbb3c52bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >CPU Core Functions HW driver header file. </p>
<dl class="section author"><dt>Author</dt><dd>Stephan Nolting </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a94cc6c8048acaaa5fdf35ad7df63ce37" name="a94cc6c8048acaaa5fdf35ad7df63ce37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94cc6c8048acaaa5fdf35ad7df63ce37">&#9670;&nbsp;</a></span>__neorv32_crt0_after_main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __neorv32_crt0_after_main </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>return_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Prototype for "after-main handler". This function is called if <a class="el" href="bitmanip__test_2main_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">return_code</td><td>Return value of <a class="el" href="bitmanip__test_2main_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return value is irrelevant (there is no one left to check for it...).</dd></dl>
<p>"after-main" handler that is executed after the application's main function returns (called by crt0.S start-up code): Output minimal test report to physical UART </p>

</div>
</div>
<a id="a386919a8b7f37c2c37d2561bfb79d1ff" name="a386919a8b7f37c2c37d2561bfb79d1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386919a8b7f37c2c37d2561bfb79d1ff">&#9670;&nbsp;</a></span>neorv32_cpu_breakpoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void neorv32_cpu_breakpoint </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Trigger breakpoint exception (via EBREAK instruction). </p>

</div>
</div>
<a id="aab7a9f9cf608599f2b124dd499cb8418" name="aab7a9f9cf608599f2b124dd499cb8418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7a9f9cf608599f2b124dd499cb8418">&#9670;&nbsp;</a></span>neorv32_cpu_csr_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t neorv32_cpu_csr_read </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>csr_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Read data from CPU configuration and status register (CSR).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">csr_id</td><td>ID of CSR to read. See <a class="el" href="neorv32_8h.html#ac065a8cc32eed9a69ea1798492a69f49">NEORV32_CSR_enum</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read data (uint32_t). </dd></dl>

</div>
</div>
<a id="afb5ef6e0b1a3e26570edfd8379490455" name="afb5ef6e0b1a3e26570edfd8379490455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5ef6e0b1a3e26570edfd8379490455">&#9670;&nbsp;</a></span>neorv32_cpu_csr_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void neorv32_cpu_csr_write </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>csr_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Write data to CPU configuration and status register (CSR).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">csr_id</td><td>ID of CSR to write. See <a class="el" href="neorv32_8h.html#ac065a8cc32eed9a69ea1798492a69f49">NEORV32_CSR_enum</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data to write (uint32_t). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9027535b13d9f9325e734997fc4a137" name="aa9027535b13d9f9325e734997fc4a137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9027535b13d9f9325e734997fc4a137">&#9670;&nbsp;</a></span>neorv32_cpu_delay_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void neorv32_cpu_delay_ms </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>time_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Delay function using busy wait.</p>
<dl class="section note"><dt>Note</dt><dd>This function uses the time CSRs (from int./ext. MTIME). A simple ASM loop is used as fall back if system timer is not advancing (no MTIME available).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Delay time might be less precise if M extensions is not available (especially if MTIME unit is not available).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time_ms</td><td>Time in ms to wait (unsigned 32-bit). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e710118af168dad99d93ddd5940d43e" name="a3e710118af168dad99d93ddd5940d43e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e710118af168dad99d93ddd5940d43e">&#9670;&nbsp;</a></span>neorv32_cpu_dint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void neorv32_cpu_dint </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Disable global CPU interrupts (via MIE flag in mstatus CSR). </p>

</div>
</div>
<a id="ae00d513794932373f6dd2766d7efb4e1" name="ae00d513794932373f6dd2766d7efb4e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae00d513794932373f6dd2766d7efb4e1">&#9670;&nbsp;</a></span>neorv32_cpu_eint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void neorv32_cpu_eint </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Enable global CPU interrupts (via MIE flag in mstatus CSR). </p>

</div>
</div>
<a id="a08a68d64b34162c5979a77bbb3c52bb6" name="a08a68d64b34162c5979a77bbb3c52bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a68d64b34162c5979a77bbb3c52bb6">&#9670;&nbsp;</a></span>neorv32_cpu_env_call()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void neorv32_cpu_env_call </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Trigger "environment call" exception (via ECALL instruction). </p>

</div>
</div>
<a id="ac3fd7dc7cd1e0a08225c41820af27f92" name="ac3fd7dc7cd1e0a08225c41820af27f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3fd7dc7cd1e0a08225c41820af27f92">&#9670;&nbsp;</a></span>neorv32_cpu_get_cycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t neorv32_cpu_get_cycle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get cycle count from cycle[h].</p>
<dl class="section note"><dt>Note</dt><dd>The cycle[h] CSR is shadowed copy of the mcycle[h] CSR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Current cycle counter (64 bit). </dd></dl>

</div>
</div>
<a id="a387aa304770b05594c4acca128a60a75" name="a387aa304770b05594c4acca128a60a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387aa304770b05594c4acca128a60a75">&#9670;&nbsp;</a></span>neorv32_cpu_get_instret()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t neorv32_cpu_get_instret </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get retired instructions counter from instret[h].</p>
<dl class="section note"><dt>Note</dt><dd>The instret[h] CSR is shadowed copy of the instret[h] CSR.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Current instructions counter (64 bit). </dd></dl>

</div>
</div>
<a id="a9d7e66d338a86207c4a510dc4d913874" name="a9d7e66d338a86207c4a510dc4d913874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7e66d338a86207c4a510dc4d913874">&#9670;&nbsp;</a></span>neorv32_cpu_get_systime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t neorv32_cpu_get_systime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get current system time from time[h] CSR.</p>
<dl class="section note"><dt>Note</dt><dd>This function requires the MTIME system timer to be implemented.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Current system time (64 bit). </dd></dl>

</div>
</div>
<a id="aca49efb45d3808ad76cf65ba291f546d" name="aca49efb45d3808ad76cf65ba291f546d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca49efb45d3808ad76cf65ba291f546d">&#9670;&nbsp;</a></span>neorv32_cpu_goto_user_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void neorv32_cpu_goto_user_mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Switch from privilege mode MACHINE to privilege mode USER.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function requires the U extension to be implemented. </dd></dl>

</div>
</div>
<a id="a59c4f8502cafca5c369297c347079d44" name="a59c4f8502cafca5c369297c347079d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c4f8502cafca5c369297c347079d44">&#9670;&nbsp;</a></span>neorv32_cpu_hpm_get_counters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t neorv32_cpu_hpm_get_counters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Hardware performance monitors (HPM): Get number of available HPM counters.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function overrides all available mhpmcounter* CSRs.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of available HPM counters (0..29). </dd></dl>

</div>
</div>
<a id="adb3ae542bbb0ddf9f562a4e42bc24d10" name="adb3ae542bbb0ddf9f562a4e42bc24d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3ae542bbb0ddf9f562a4e42bc24d10">&#9670;&nbsp;</a></span>neorv32_cpu_hpm_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t neorv32_cpu_hpm_get_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Hardware performance monitors (HPM): Get total counter width</p>
<dl class="section warning"><dt>Warning</dt><dd>This function overrides mhpmcounter3[h] CSRs.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Size of HPM counter bits (1-64, 0 if not implemented at all). </dd></dl>

</div>
</div>
<a id="a57c3b55f5b7042ed2470b2fe7d0ce0c7" name="a57c3b55f5b7042ed2470b2fe7d0ce0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c3b55f5b7042ed2470b2fe7d0ce0c7">&#9670;&nbsp;</a></span>neorv32_cpu_irq_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int neorv32_cpu_irq_disable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>irq_sel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Disable specific CPU interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">irq_sel</td><td>CPU interrupt select. See <a class="el" href="neorv32_8h.html#a0e9714690687badee43180c3cb62be33">NEORV32_CSR_MIE_enum</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error (invalid irq_sel). </dd></dl>

</div>
</div>
<a id="a1128a30988815e8195618da07c13a345" name="a1128a30988815e8195618da07c13a345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1128a30988815e8195618da07c13a345">&#9670;&nbsp;</a></span>neorv32_cpu_irq_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int neorv32_cpu_irq_enable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>irq_sel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Enable specific CPU interrupt.</p>
<dl class="section note"><dt>Note</dt><dd>Interrupts have to be globally enabled via <a class="el" href="neorv32__cpu_8h.html#ae00d513794932373f6dd2766d7efb4e1">neorv32_cpu_eint(void)</a>, too.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">irq_sel</td><td>CPU interrupt select. See <a class="el" href="neorv32_8h.html#a0e9714690687badee43180c3cb62be33">NEORV32_CSR_MIE_enum</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error (invalid irq_sel). </dd></dl>

</div>
</div>
<a id="a75a8539d4e17d6a409f288e118bc46af" name="a75a8539d4e17d6a409f288e118bc46af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a8539d4e17d6a409f288e118bc46af">&#9670;&nbsp;</a></span>neorv32_cpu_load_reservate_word()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t neorv32_cpu_load_reservate_word </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Load unsigned word from address space and make reservation for atomic access.</p>
<dl class="section note"><dt>Note</dt><dd>An unaligned access address will raise an alignment exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Address (32-bit). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read data word (32-bit). </dd></dl>

</div>
</div>
<a id="ac54ec9b59e17c7cd9b9907abee82ce95" name="ac54ec9b59e17c7cd9b9907abee82ce95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54ec9b59e17c7cd9b9907abee82ce95">&#9670;&nbsp;</a></span>neorv32_cpu_load_unsigned_byte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t neorv32_cpu_load_unsigned_byte </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Load unsigned byte from address space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Address (32-bit). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read data byte (8-bit). </dd></dl>

</div>
</div>
<a id="a32544cd652debb4affb308806a115d5b" name="a32544cd652debb4affb308806a115d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32544cd652debb4affb308806a115d5b">&#9670;&nbsp;</a></span>neorv32_cpu_load_unsigned_half()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t neorv32_cpu_load_unsigned_half </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Load unsigned half-word from address space.</p>
<dl class="section note"><dt>Note</dt><dd>An unaligned access address will raise an alignment exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Address (32-bit). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read data half-word (16-bit). </dd></dl>

</div>
</div>
<a id="a3b6cf445e2136486564ef3d3473c91dd" name="a3b6cf445e2136486564ef3d3473c91dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6cf445e2136486564ef3d3473c91dd">&#9670;&nbsp;</a></span>neorv32_cpu_load_unsigned_word()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t neorv32_cpu_load_unsigned_word </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Load unsigned word from address space.</p>
<dl class="section note"><dt>Note</dt><dd>An unaligned access address will raise an alignment exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Address (32-bit). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read data word (32-bit). </dd></dl>

</div>
</div>
<a id="a17dd397ea7409a1ecb0ea50b61e738a5" name="a17dd397ea7409a1ecb0ea50b61e738a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17dd397ea7409a1ecb0ea50b61e738a5">&#9670;&nbsp;</a></span>neorv32_cpu_pmp_configure_region()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int neorv32_cpu_pmp_configure_region </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Physical memory protection (PMP): Configure region.</p>
<dl class="section note"><dt>Note</dt><dd>Using NAPOT mode - page base address has to be naturally aligned.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function requires the PMP CPU extension. </dd>
<dd>
Only use available PMP regions. Check before using neorv32_cpu_pmp_get_regions(void).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Region number (index, 0..PMP_NUM_REGIONS-1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>Region base address (has to be naturally aligned!). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Region size, has to be a power of 2 (min 8 bytes or according to HW's PMP.granularity configuration). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Region configuration (attributes) byte (for PMPCFGx). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, 1 on failure. </dd></dl>

</div>
</div>
<a id="ad4f8160f4821b6691e9682ef60c7cd7b" name="ad4f8160f4821b6691e9682ef60c7cd7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f8160f4821b6691e9682ef60c7cd7b">&#9670;&nbsp;</a></span>neorv32_cpu_pmp_get_granularity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t neorv32_cpu_pmp_get_granularity </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Physical memory protection (PMP): Get minimal region size (granularity).</p>
<dl class="section warning"><dt>Warning</dt><dd>This function overrides PMPCFG0[0] and PMPADDR0 CSRs. </dd>
<dd>
This function requires the PMP CPU extension.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns minimal region size in bytes. </dd></dl>

</div>
</div>
<a id="a27dd614bc270dfa30ed73323ebda2d2d" name="a27dd614bc270dfa30ed73323ebda2d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27dd614bc270dfa30ed73323ebda2d2d">&#9670;&nbsp;</a></span>neorv32_cpu_pmp_get_num_regions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t neorv32_cpu_pmp_get_num_regions </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Physical memory protection (PMP): Get number of available regions.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function overrides all available PMPCFG* CSRs. </dd>
<dd>
This function requires the PMP CPU extension.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of available PMP regions. </dd></dl>

</div>
</div>
<a id="a232d0290c459dc790d989fcdc4d121bf" name="a232d0290c459dc790d989fcdc4d121bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232d0290c459dc790d989fcdc4d121bf">&#9670;&nbsp;</a></span>neorv32_cpu_set_mcycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void neorv32_cpu_set_mcycle </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set mcycle[h] counter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>New value for mcycle[h] CSR (64-bit). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c3cf52498abb3cf3c14a724b287ecf0" name="a5c3cf52498abb3cf3c14a724b287ecf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3cf52498abb3cf3c14a724b287ecf0">&#9670;&nbsp;</a></span>neorv32_cpu_set_minstret()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void neorv32_cpu_set_minstret </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set retired instructions counter minstret[h].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>New value for mcycle[h] CSR (64-bit). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a769ca4556213619f6fea4ff6bfb979dd" name="a769ca4556213619f6fea4ff6bfb979dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a769ca4556213619f6fea4ff6bfb979dd">&#9670;&nbsp;</a></span>neorv32_cpu_sleep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void neorv32_cpu_sleep </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Put CPU into "sleep" mode.</p>
<dl class="section note"><dt>Note</dt><dd>This function executes the WFI instruction. The WFI (wait for interrupt) instruction will make the CPU stall until an interrupt request is detected. Interrupts have to be globally enabled and at least one external source must be enabled (like the MTI machine timer interrupt) to allow the CPU to wake up again. If 'Zicsr' CPU extension is disabled, this will permanently stall the CPU. </dd></dl>

</div>
</div>
<a id="a198a49fc1b6c243418f29af9bbe19cec" name="a198a49fc1b6c243418f29af9bbe19cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a198a49fc1b6c243418f29af9bbe19cec">&#9670;&nbsp;</a></span>neorv32_cpu_store_conditional()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t neorv32_cpu_store_conditional </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Store unsigned word to address space if atomic access reservation is still valid.</p>
<dl class="section note"><dt>Note</dt><dd>An unaligned access address will raise an alignment exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Address (32-bit). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wdata</td><td>Data word (32-bit) to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status (32-bit, zero if success). </dd></dl>

</div>
</div>
<a id="aeec8ad2a82885c40a307346f9003483e" name="aeec8ad2a82885c40a307346f9003483e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec8ad2a82885c40a307346f9003483e">&#9670;&nbsp;</a></span>neorv32_cpu_store_unsigned_byte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void neorv32_cpu_store_unsigned_byte </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>wdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Store unsigned byte to address space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Address (32-bit). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wdata</td><td>Data byte (8-bit) to store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31f30f6d6542758cd3073a9939b07653" name="a31f30f6d6542758cd3073a9939b07653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f30f6d6542758cd3073a9939b07653">&#9670;&nbsp;</a></span>neorv32_cpu_store_unsigned_half()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void neorv32_cpu_store_unsigned_half </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Store unsigned half-word to address space.</p>
<dl class="section note"><dt>Note</dt><dd>An unaligned access address will raise an alignment exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Address (32-bit). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wdata</td><td>Data half-word (16-bit) to store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a173bb06b4ae9c8964469068dafcb7b0e" name="a173bb06b4ae9c8964469068dafcb7b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173bb06b4ae9c8964469068dafcb7b0e">&#9670;&nbsp;</a></span>neorv32_cpu_store_unsigned_word()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void neorv32_cpu_store_unsigned_word </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Conditional store unsigned word to address space.</p>
<dl class="section note"><dt>Note</dt><dd>An unaligned access address will raise an alignment exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Address (32-bit). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wdata</td><td>Data word (32-bit) to store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
